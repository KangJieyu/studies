# Spring

## Spring 框架

Spring 框架是轻量级的 Java 开发框架，整合了诸如 JDBC 、MyBatis 等架构，减少了开发过程中的复杂性，拥有 AOP (面向切面的编程)和 IoC (控制反转)主要两大核心内容，追求代码的解耦和复用。

## IoC

IoC (Inversion of Control) ，控制反转，是 Spring 容器对对象的管理，由 Spring 容器来帮助我们进行对象创建和依赖注入(Dependency Injection)，我们在开发过程中可以直接使用这些对象。

### 创建对象

#### 基于XML配置文件

- 创建一个实体类，com.spring.Person.java
  
  ```java
  public class Person {
      private String name;
      private int age;
  
      public Person() {
          System.out.println("new Person()");
      }
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
          System.out.println("new Person(name, age)");
      }
  
      @Override
      public String toString() {
          return "Person{" +
                  "name='" + name + '\'' +
                  ", age=" + age +
                  '}';
      } 
  }
  ```

- 传统创建对象方式
  
  ```java
  Person p1 = new Person();
  ```

- Spring 创建对象方式
  
  - 在配置文件 applicationContext.xml 中创建，id 值为对象名称，class 值为对象类全名，用此方式创建对象，默认调用无参改造方法，所以 **<mark>必需提供无参构造方法</mark>**
    
    ```xml
    <bean id="p1" class="com.spring.Person"></bean>
    ```
  
  - 利用有参构造方法创建对象
    
    > - 通过构造方法参数名
    > 
    > - 通过构造方法参数下标
    > 
    > - 通过构造方法参数的默认顺序
    
    ```xml
    <!-- 通过参数名称创建 -->
    <bean id="p2" class="com.spring.Person">
        <constructor-arg name="name" value="wangwu" />
        <constructor-arg name="age" value="20" />
    </bean>
    <!-- 通过参数下标创建 -->
    <bean id="p3" class="com.spring.Person">
        <constructor-arg index="0" value="wangwu" />
        <constructor-arg index="1" value="20" />
    </bean>
    <!-- 通过参数默认顺序创建 -->
    <bean id="p3" class="com.spring.Person">
        <constructor-arg name="name" value="wangwu" />
        <constructor-arg name="age" value="20" />
    </bean>
    ```

- Spring 帮助我们创建完对象，我们如何获取对象使用？
  
  ```java
  // 创建容器对象并启动容器
  // 在这里对调用无参构造方法，为每个 bean 标签创建对象
  ApplicationContext context = 
             new ClassPathXmlApplicationContext("applicationContext.xml");
  // 获取容器创建的对象
  Person p1 = (Person) context.getBean("p1");
  ```

- 创建对象的同时为属性赋值，为属性赋值，name 值为属性名，**<mark>必须提供setXXX(XXX)方法</mark>**
  
  > 基本类型属性赋值用 value
  > 
  > 引用类型属性赋值用 ref，该引用类型的数据应在 Spring 容器中创建过的对象，也可称为 DI
  
  这里创建一个com.spring.Company类，作为 Person 类的属性
  
  ```java
  public class Company {
      private String name;
      private int salary;
      private String position;
      @Override
      public String toString() {
          return "Company{" +
                  "name='" + name + '\'' +
                  ", salary='" + salary + '\'' +
                  ", position='" + position + '\'' +
                  '}';
      }
  }
  ```
  
  - 修改 Person 类中的 toString() 方法并添加 Company 对象的属性和 setCompany(company)方法
  
  ```xml
  <bean id="p1" class="com.spring.Person">
      <!-- 基本类型属性 -->
      <property name="name" value="李四" />
      <property name="age" value="18" />
      <!-- 引用类型属性，ref 值为 spring容器创建的对象id -->
      <property name="company" ref="company" />
  </bean>
  
  <!-- 创建Company 对象-->
  <bean id="company" class="com.spring.domain.Company">
      <property name="name" value="XXX公司" />
      <property name="salary" value="10000" />
      <property name="position" value="项目经理" />
  </bean>
  ```

#### 基于注解

```java
@Component("stu") // @Component 创建对象名称默认为student
public class Student {
    @Value("zhangsan") // 不需要 set 方法
    private String name;
    @Value("18")
    private int age;
    @Value("女")
    private String sex;
    @Autowired
    @Qualifier("school") // School 类中 Component 无参数，默认实体Bean名称为 school
    private School school;

    public Student() {}
}
```

基于注解创建对象，需要在 .xml 文件中配置包扫描机制

```xml
<!-- 在配置多个包扫描时，base-package 值中多个包间可用逗号分隔 -->
<context:component-scan base-package="com.spring" />
```

当有多个XML文件，需整合配置文件，xml 文件导入方式

```xml
<!-- 单个文件导入 -->
<import resource="application.xml" />
<!-- 多个文件的导入，将名字为 application_XXXXX 的 xml 都进行导入 -->
<import resource="application_*.xml" />
```

创建一个 School ，用于在 Student 类中 `@Autowired` 引用类型注入

```java
@Component
public class School {
    @Value("北大")
    private String name;
    @Value("北京")
    private String address;

    public School() {}
}
```

- `@Component`
  
  是类类型的注解，可用于在 Spring 管理的任何组件
  
  对象默认为类名小驼峰式，我们也可以自定义名称

- `@Controller`
  
  在表示层/控制层创建对象使用

- `@Service`
  
  在服务层创建对象使用

- `Repository`
  
  在数据持久层创建对象使用

- `@Value`
  
  可用于属性、方法或构造方法参数级别上，用于注入基本类型和 String 类型数据
  
  优点在于不用写属性的 setXXX(XXX) 方法

- `@Autowired`
  
  用于类型匹配注入值，常用于注入引用类型
  
  > `@Autowired`在被注入类具有子父类关系注入时，有多个类型进行注入，Spring 会进行筛选，选取名字一样的进行注入，为避免错误，则可使用`@Autowired`于`@Qualifioer`结合指定名称进行注入

- `@Autowire` 和 `@Qualifior`
  
  用于引用类型通过 bean 名称注入，使用`@Qualifior`时必须指定注入的名称

## AOP

AOP，面向切面编程，他是将业务逻辑的公共部分进行抽取，实现业务逻辑部分与各个部分进行解耦，提高代码的复用性，实际则为动态代理。

### Spring中实现

前置通知

后置通知

环绕通知

异常通知

### 常应术语

1. 切面：增强的功能

2. 连接点

3. 切入点
   
   要增强功能的位置/方法
   
   切入点表达式：
   
   `execution([访问权限] 方法返回值 方法名(参数) [异常])`

4. 目标对象

5. 通知

### AspectJ

基于 Java 语言开发的一个面向切面的框架，可实现无缝扩展

业务对象和切面的绑定 `<aop:aspectj-autoproxy></aop:aspectj-autoproxy>`

#### 通知注解

**常见的切面类型**

- `@Aspect`
  
  切面类注解，注解一个切面类，AspectJ 框架扫描注解识别切面

- `@Before(value = "切入点表达式")`
  
  通知方法：public void methos([JoinPoint joinPoint])
  
  在切面方法中可有一个参数 `JoinPoint` 对象，可获得目标方法的签名(访问权限、返回值类型、方法名全路径、参数类型)和参数内容

- `@AfterReturning(value = "切入点表达式", returning = "目标方法的返回值名称，要与切面方法的参数名一致")`
  
  通知方法：public void method([Object obj])
  
  切面方法中的参数 `Object` 为目标方法的返回值，在切面方法中可根据需要进行处理

- `@Around(value = "切入点表达式")`
  
  在目标方法执行前后增强功能，一般用于事务处理，可改变目标方法的返回值
  
  通知方法：public return  method(ProceedingJoinPoint point)
  
  参数为目标对象

- `@After(value = "切入点表达式")`
  
  无论目标方法是否正常执行，最终通知都会执行，异常使用
  
  通知方法：public void method([JoinPoint point])
  
  ---

- `@Pointcut(value = "切入点表达式")`
  
  > `@Pointcut` 注解即为一个切入点表达式的别名，如下代码，可在通知注解中使用，如 `@Before(value = "cut()")`
  
  ```java
  @Pointcut(value = "execution(returntype method(argstype)")
  public void cut() {}
  ```

## 事务

### Spring 的事务管理

1. 注解式
   
   `@transactional`
   
   > 在业务方法上进行添加，对该业务类中的所有方法都有效
   
   - propagation 设置事务的传播特性
   
   - noRollbackForClassName 指定发生异常不回滚
   
   - rollbackForClassName 指定异常发生回滚
   
   - timeout 设置连接超时，默认值为 -1，永不超时
   
   - reaOnly 默认 false，允许增删改，若为查询，则必须设置为 true
   
   - isolation 设置数据的隔离级别，一般为 Isolation.DEFAULT

2. 声明式
   
   在配置文件中添加

### 五大级别

1. read uncommitted
   
   未提交读：允许读取事务未提交的数据，允许脏读

2. read committed
   
   提交读：允许读取事务提交的数据，

3. repeatable read
   
   可重复读：

4. serializable
   
   串读：较少

5. default

MySQL：默认处理级别为 可重复读

Oracle：支持 read committed 和 serializable ，默认为 读已提交

### 传播特性

多个事务之间的合并、互斥等，都可通过设置事务的传播特性解决。

# 



# 项目配置

## db.properties文件

```properties
jdbc.driverClassName=com.mysql.cj.jdbc.Driver # mysql 8
jdbc.url=jdbc:mysql://localhost:3306/database
jdbc.username=root
jdbc.password=123456
```

## pom.xml文件

```xml
<build>
    <resources>
        <directory>src/main/resources</directory>
        <includes>
            <include>**/*.xml</include>
        </includes>
    </resources>
</build>
```

## spring application.xml

- 读取 properties 属性文件

- 创建数据源( druid 数据库连接池)

- 配置 SqlSessionFactoryBeean
  
  - 配置数据源
  
  - 配置 MyBatis 的核心配置
  
  - 注册实体类别名

- 注册 mapper.xml

- 事务
  
  - 添加事务管理器，配置数据源
  
  - 添加事务注解驱动

```xml
<context:property-placeholder location="db.properties" />

<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="jdbc.driverClassName" />
    <property name="url" value="jdbc.url" />
    <property name="username" value="jdbc.username" />
    <property name="password" value="jdbc.password" />
</bean>

<bean class="com.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource" />
    <property name="configLocation" value="SqlMapConfig.xml" />
    <property name="typeAliasesPackage" value="domainPackage" />
</bean>

<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="mapperPackage" />
</bean>

<bean id="transactionManager" class="org.springframework.jdbc.
                         datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource" />
</bean>
<tx:annotation-driven transaction-manager="transactionManager">
</tx:annotation-driven>
```
